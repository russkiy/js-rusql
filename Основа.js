const
    Запустить = require('sql.js'),
    ФС = require('fs').promises;

const
    Ошибка = Error,
    Стиль_параметров = 'qmark';

const Словарь_перевода = {
    'НАЧАТЬ': 'BEGIN',
    'ЗАВЕРШИТЬ': 'END',
    'ТРАНЗАКЦИЮ': 'TRANSACTION',
    'УТВЕРДИТЬ': 'COMMIT',
    'ОТКАТИТЬ': 'ROLLBACK',
    'ТОЧКА СОХРАНЕНИЯ': 'SAVEPOINT',
    'ВЫБРАТЬ': 'SELECT',
    'ИЗ': 'FROM',
    'ГДЕ': 'WHERE',
    'УПОРЯДОЧИВ ПО': 'ORDER BY',
    'ПО ВОЗРАСТАНИЮ': 'ASC',
    'ПО УБЫВАНИЮ': 'DESC',
    'ГРУППАМИ ПО': 'GROUP BY',
    'ИМЕЮЩИМИ': 'HAVING',
    'РАЗЛИЧАЮЩИЕСЯ': 'DISTINCT',
    'ОБЪЕДИНИВ С': 'UNION',
    'СОДЕРЖАЩИЕСЯ В': 'INTERSECT',
    'ВСЕ': 'ALL',
    'НЕКОТОРЫЕ': 'ANY',
    'ИСКЛЮЧАЯ': 'EXCEPT',
    'НЕ БОЛЕЕ': 'LIMIT',
    'СО СМЕЩЕНИЕМ': 'OFFSET',
    'ПРИСОЕДИНИВ': 'JOIN',
    'ВНУТРЕННЕ': 'INNER',
    'ВНЕШНЕ': 'OUTER',
    'ПО ЛЕВОЙ': 'LEFT',
    'ПО ПРАВОЙ': 'RIGHT',
    'ПОЛНОСТЬЮ': 'FULL',
    'ПО': 'ON',
    'ПЕРЕКРЁСТНО': 'CROSS',
    'ИСПОЛЬЗУЯ': 'USING',
    'ВСТАВИТЬ ИЛИ ___ В': 'INSERT OR ___ INTO',
    'ДОБАВИТЬ В': 'INSERT INTO',
    'ЗНАЧЕНИЯ': 'VALUES',
    'ИЗМЕНИТЬ': 'UPDATE',
    'УСТАНОВИВ': 'SET',
    'УДАЛИТЬ ИЗ': 'DELETE FROM',
    'ПРИ КОНФЛИКТЕ': 'ON CONFLICT',
    'ПРИ УДАЛЕНИИ': 'ON DELETE',
    'ПРИ ИЗМЕНЕНИИ': 'ON UPDATE',
    'КАСКАДНО': 'CASCADE',
    'УСТАНОВИТЬ ПУСТЫМ': 'SET NULL',
    'УСТАНОВИТЬ ПО УМОЛЧАНИЮ': 'SET DEFAULT',
    'ОГРАНИЧИТЬ': 'RESTRICT',
    'БЕЗ ДЕЙСТВИЯ': 'NO ACTION',
    'ВЫПОЛНЯТЬ': 'DO',
    'НИЧЕГО': 'NOTHING',
    'ПРОПУСТИТЬ': 'IGNORE',
    'ПРЕРВАТЬ': 'ABORT',
    'ЗАМЕНИТЬ': 'REPLACE',
    'СБОЙ': 'FAIL',
    'СОЗДАТЬ': 'CREATE',
    'УДАЛИТЬ': 'DROP',
    'ТАБЛИЦУ': 'TABLE',
    'ВРЕМЕННУЮ': 'TEMPORARY',
    'ДОБАВИВ': 'ADD',
    'УДАЛИВ': 'DROP',
    'ИНДЕКС': 'INDEX',
    'УНИКАЛЬНЫЙ': 'UNIQUE',
    'ПРЕДСТАВЛЕНИЕ': 'VIEW',
    'СТОЛБЕЦ': 'COLUMN',
    'ТРИГГЕР': 'TRIGGER',
    'ЯВЛЯЕТСЯ ПУСТЫМ': 'IS NULL',
    'НЕ ЯВЛЯЕТСЯ ПУСТЫМ': 'IS NOT NULL',
    'НЕ ПУСТОЕ': 'NOT NULL',
    'ПУСТО': 'NULL',
    'ЦЕЛОЕ': 'INTEGER',
    'ВЕЩЕСТВЕННОЕ': 'REAL',
    'ТЕКСТ': 'TEXT',
    'ДАННЫЕ': 'BLOB',
    'КЛЮЧ': 'KEY',
    'ПЕРВИЧНЫЙ': 'PRIMARY',
    'ВНЕШНИЙ': 'FOREIGN',
    'ПРОВЕРЯТЬ': 'CHECK',
    'КАК': 'AS',
    'ДА': 'TRUE',
    'НЕТ': 'FALSE',
    'ПО УМОЛЧАНИЮ': 'DEFAULT',
    'САМОУВЕЛИЧИВАЮЩЕЕСЯ': 'AUTOINCREMENT',
    'ССЫЛАЕТСЯ НА': 'REFERENCES',
    'И': 'AND',
    'ИЛИ': 'OR',
    'НЕ': 'NOT',
    'ПОДОБНО': 'LIKE',
    'МЕЖДУ': 'BETWEEN',
    'В': 'IN',
    'ЕСЛИ': 'IF',
    'СУЩЕСТВУЕТ': 'EXISTS',
    'БЕЗ': 'WITHOUT',
    'ОПРЕДЕЛИВ': 'WITH',
    'ВЫБОР': 'CASE',
    'ПРИ': 'WHEN',
    'ЭТО': 'THEN',
    'КОНЕЦ': 'END',
    'РЕКУРСИВНО': 'RECURSIVE',
    'КОЛИЧЕСТВО': 'COUNT',
    'СУММА': 'SUM',
    'СРЕДНЕЕ': 'AVG',
    'НАИМЕНЬШЕЕ': 'MIN',
    'НАИБОЛЬШЕЕ': 'MAX',
    'СЦЕПИТЬ': 'CONCAT',
    'ДЛИНА': 'LENGTH',
    'В_ЗАГЛАВНЫЕ': 'UPPER',
    'В_СТРОЧНЫЕ': 'LOWER',
    'ПОДСТРОКА': 'SUBSTR',
    'ЗАМЕНИТЬ': 'REPLACE',
    'ОКРУГЛИТЬ': 'ROUND',
    'ОКРУГЛИТЬ_ВНИЗ': 'FLOOR',
    'ОКРУГЛИТЬ_ВВЕРХ': 'CEIL',
    'МОДУЛЬ': 'ABS',
    'ТИП_ДАННЫХ': 'TYPEOF',
    'ПОСЛЕДНИЙ_ИДЕНТИФИКАТОР': 'LAST_INSERT_ROWID',
    'ЗНАК': 'SIGN',
    'ЕСЛИ_ПУСТО': 'IFNULL',
    'ЯВЛЯЕТСЯ_ПУСТЫМ': 'NULLIF',
    'СОВПАДЕНИЕ': 'LIKE',
    'ГЛОБАЛЬНОЕ_СОВПАДЕНИЕ': 'GLOB',
    'ОБРЕЗАТЬ': 'TRIM',
    'ОБРЕЗАТЬ_СЛЕВА': 'LTRIM',
    'ОБРЕЗАТЬ_СПРАВА': 'RTRIM'
};

const Переводы_ошибок = [
    [/no such table: (.+)/i, 'Таблица "$1" не существует.'],
    [/near "(.+)": syntax error/i, 'Синтаксическая ошибка около "$1".'],
    [/table (.+) already exists/i, 'Таблица "$1" уже существует.'],
    [/no such column: (.+)/i, 'Столбец "$1" не существует.'],
    [/(.+) has no column named (.+)/i, 'Таблица "$1" не имеет столбца "$2".'],
    [/cannot open database file/i, 'Не удалось открыть файл базы данных.'],
    [/file is not a database/i, 'Файл не является базой данных.'],
    [/database disk image is malformed/i, 'Образ диска базы данных повреждён.'],
    [/incorrect number of bindings supplied. The statement has (\d+) parameters, and (\d+) were supplied/i, 'Неверное количество переданных параметров. Ожидаемых запросом параметров - $1, передано - $2.'],
    [/You did not supply a value for binding (\d+)/i, 'Не указано значение для параметра $1.'],
    [/Cannot operate on a closed database/i, 'Невозможно выполнить операцию на закрытой базе данных.'],
    [/column (.+) is not unique/i, 'Столбец "$1" должен быть уникальным.'],
    [/number of bound variables does not match number of parameters/i, 'Количество привязанных переменных не соответствует количеству параметров.'],
    [/only one statement is allowed/i, 'Разрешено выполнять только один запрос за раз.'],
    [/NOT NULL constraint failed: (.+)/i, 'Нарушение ограничения НЕ ПУСТОЕ для столбца "$1".'],
    [/UNIQUE constraint failed: (.+)/i, 'Нарушение ограничения УНИКАЛЬНЫЙ для столбца "$1".'],
    [/CHECK constraint failed: (.+)/i, 'Нарушение ограничения ПРОВЕРЯТЬ: $1.'],
    [/PRIMARY KEY must be unique/i, 'Первичный ключ должен быть уникальным.'],
    [/Error binding parameter (\d+) - probably unsupported type/i, 'Ошибка привязки параметра $1 - вероятно, неподдерживаемый тип.'],
    [/constraint failed/i, 'Нарушение ограничения.'],
    [/no such function: (.+)/i, 'Функция "$1" не существует.'],
    [/parameters are of unsupported type/i, 'Параметры имеют неподдерживаемый тип.'],
    [/out of memory/i, 'Недостаточно памяти для выполнения операции.'],
    [/WebAssembly compilation failed/i, 'Не удалось скомпилировать WebAssembly-модуль.'],
    [/table (.+) has (\d+) columns but (\d+) values were supplied/i, 'Столбцов в таблице "$1" - $2, но получено значений - $3.']
];

function Получить_токены(запрос) {
    const токены = [];
    let текущий_токен = '';
    let в_строке = false;
    let строка_символ = null;
    let сч_1 = 0;

    while (сч_1 < запрос.length) {
        const символ = запрос[сч_1];

        if (символ === '\\' && в_строке && сч_1 + 1 < запрос.length) {
            текущий_токен += символ + запрос[сч_1 + 1];
            сч_1 += 2;
            continue;
        }

        if (символ === '"' || символ === "'") {
            if (в_строке && символ === строка_символ) {
                в_строке = false;
                текущий_токен += символ;
                токены.push(текущий_токен);
                текущий_токен = '';
                сч_1++;
                continue;
            }
            else if (!в_строке) {
                в_строке = true;
                строка_символ = символ;
                if (текущий_токен) {
                    токены.push(текущий_токен);
                    текущий_токен = '';
                }
                текущий_токен = символ;
                сч_1++;
                continue;
            }
        }

        if (в_строке) {
            текущий_токен += символ;
            сч_1++;
            continue;
        }

        if (символ.match(/\s/) || ',;()=<>!'.includes(символ)) {
            if (текущий_токен) {
                токены.push(текущий_токен);
                текущий_токен = '';
            }
            if (!символ.match(/\s/)) {
                токены.push(символ);
            }
            сч_1++;
            continue;
        }

        текущий_токен += символ;
        сч_1++;
    }

    if (текущий_токен) {
        токены.push(текущий_токен);
    }

    return токены;
}

function Перевести_токены(токены) {
    const переведённые_токены = [];
    let сч_1 = 0;

    while (сч_1 < токены.length) {
        const токен = токены[сч_1];

        if (
            токен.startsWith('"') ||
            токен.startsWith("'") ||
            ',;()=<>!'.includes(токен)
        ) {
            переведённые_токены.push(токен);
            сч_1++;
            continue;
        }

        let найдено_ключевое_слово = false;
        for (let длина = 5; длина > 0; длина--) {
            if (сч_1 + длина > токены.length) continue;

            const фраза = токены.slice(сч_1, сч_1 + длина).join(' ').toUpperCase();

            for (const [ключ, значение] of Object.entries(Словарь_перевода)) {
                if (ключ.includes('___')) {
                    const части = ключ.split('___');
                    const шаблон = '^' + части[0].replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '(\\S+)' + части[1].replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$';
                    const совпадение = фраза.match(new RegExp(шаблон));
                    if (совпадение) {
                        const переменная = совпадение[1].toUpperCase();
                        const переведённая_переменная = Словарь_перевода[переменная] || переменная;
                        const переведённая_фраза = значение.replace('___', переведённая_переменная);
                        переведённые_токены.push(переведённая_фраза);
                        сч_1 += длина;
                        найдено_ключевое_слово = true;
                        break;
                    }
                }
                else if (фраза === ключ) {
                    переведённые_токены.push(значение);
                    сч_1 += длина;
                    найдено_ключевое_слово = true;
                    break;
                }
            }
            if (найдено_ключевое_слово) break;
        }

        if (!найдено_ключевое_слово) {
            переведённые_токены.push(токен);
            сч_1++;
        }
    }

    return переведённые_токены;
}

function Собрать_запрос(токены) {
    let запрос = '';
    for (let сч_1 = 0; сч_1 < токены.length; сч_1++) {
        const токен = токены[сч_1];
        if (',;()=<>!'.includes(токен)) {
            запрос += токен;
        }
        else {
            if (сч_1 > 0 && !',;(=<>!'.includes(токены[сч_1 - 1])) {
                запрос += ' ';
            }
            запрос += токен;
        }
    }
    return запрос.trim();
}

function Перевести_код_запроса(текст) {
    const
        токены = Получить_токены(текст),
        переведённые_токены = Перевести_токены(токены);
    return Собрать_запрос(переведённые_токены);
}

function Перевести_ошибку(исключение) {
    const сообщение = String(исключение.message || исключение);
    for (const [шаблон, перевод] of Переводы_ошибок) {
        if (шаблон.test(сообщение)) {
            return new Ошибка(сообщение.replace(шаблон, перевод));
        }
    }
    return new Ошибка(сообщение);
}

class Указатель {
    constructor(база_данных, указатель, для_выборки = false) {
        this.база_данных = база_данных;
        this.указатель = указатель;
        this.для_выборки = для_выборки;
    }

    async Извлечь_запись() {
        if (!this.для_выборки)
            throw new Ошибка('Невозможно извлечь запись для не-ВЫБРАТЬ запроса.');
        try {
            const результат = this.указатель.step() ? this.указатель.getAsObject() : null;
            if (!this.указатель.step()) this.указатель.free();
            return результат;
        }
        catch (ош) {
            throw Перевести_ошибку(ош);
        }
    }

    async Извлечь_все_записи() {
        if (!this.для_выборки)
            throw new Ошибка('Невозможно извлечь записи для не-ВЫБРАТЬ запроса.');
        try {
            const результаты = [];
            while (this.указатель.step()) {
                результаты.push(this.указатель.getAsObject());
            }
            this.указатель.free();
            return результаты;
        }
        catch (ош) {
            throw Перевести_ошибку(ош);
        }
    }

    async Закрыть() {
        try {
            this.указатель.free();
        }
        catch (ош) {
            throw Перевести_ошибку(ош);
        }
    }

    get описание() {
        return this.указатель.getColumnNames() || null;
    }

    get количество_строк() {
        return this.база_данных.getRowsModified() || 0;
    }

    get последний_идентификатор() {
        return this.база_данных.lastInsertRowId() || 0;
    }
}

class Соединение {
    constructor(база_данных, путь) {
        this.база_данных = база_данных;
        this.путь = путь;
    }

    static async Открыть(путь, { является_ссылкой = false } = {}) {
        try {
            const SQL = await Запустить();
            let база_данных;
            if (путь.toLowerCase() === ':память:') {
                база_данных = new SQL.Database();
            }
            else {
                const ФС = require('fs').promises;
                let буфер_файла;
                if (является_ссылкой) {
                    буфер_файла = путь;
                }
                else {
                    try {
                        буфер_файла = await ФС.readFile(путь);
                    }
                    catch (ош) {
                        if (ош.code === 'ENOENT') {
                            база_данных = new SQL.Database();
                            return new Соединение(база_данных, путь);
                        }
                        throw ош;
                    }
                }
                база_данных = new SQL.Database(буфер_файла);
            }
            return new Соединение(база_данных, путь);
        }
        catch (ош) {
            throw Перевести_ошибку(ош);
        }
    }

    async Выполнить_запрос(запрос, параметры = []) {
        try {
            const
                переведённый = Перевести_код_запроса(запрос),
                для_выборки = переведённый.trim().toUpperCase().startsWith('SELECT'),
                указатель = this.база_данных.prepare(переведённый);
            if (параметры.length > 0) указатель.bind(параметры);
            if (!для_выборки) {
                указатель.run();
                указатель.free();
            }
            return new Указатель(this.база_данных, указатель, для_выборки);
        }
        catch (ош) {
            throw Перевести_ошибку(ош);
        }
    }

    async Выполнить_сценарий(сценарий) {
        try {
            const переведённый = Перевести_код_запроса(сценарий);
            this.база_данных.exec(переведённый);
        }
        catch (ош) {
            throw Перевести_ошибку(ош);
        }
    }

    async Закрыть() {
        await this.Сохранить();
        try {
            this.база_данных.close();
        }
        catch (ош) {
            throw Перевести_ошибку(ош);
        }
    }

    async Сохранить(путь = null) {
        try {
            if (!путь) путь = this.путь;
            const данные = this.база_данных.export();
            await ФС.writeFile(путь, Buffer.from(данные));
        }
        catch (ош) {
            throw Перевести_ошибку(ош);
        }
    }
}

module.exports = Соединение;
